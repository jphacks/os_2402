# Project Architecture

This document provides an overview of the architecture and design patterns used in this project. Each component is described along with key decisions and the rationale behind them.

---

## Table of Contents

- [Project Architecture](#project-architecture)
  - [Table of Contents](#table-of-contents)
  - [Overview](#overview)
  - [Architecture Breakdown](#architecture-breakdown)
    - [Frontend (Flutter/Dart)](#frontend-flutterdart)
    - [Backend (Gin/Go)](#backend-gingo)
    - [Machine Learning (FastAPI/Python)](#machine-learning-fastapipython)
    - [Infrastructure (Terraform / DevSecOps)](#infrastructure-terraform--devsecops)
  - [Data Flow and Communication](#data-flow-and-communication)
  - [Design Patterns](#design-patterns)
  - [Additional Notes](#additional-notes)

---

## Overview

This project is structured as a **modular monorepo** that consolidates the frontend, backend, machine learning, and infrastructure configurations under one repository. We’ve chosen this architecture to ensure consistency, facilitate code sharing (e.g., GraphQL schema), and streamline CI/CD processes.

## Architecture Breakdown

### Frontend (Flutter/Dart)

- **Framework**: Flutter with **MVVM (Model-View-ViewModel)** architecture.
- **State Management**:
  - **Ephemeral State**: `flutter_hooks` for widget-specific state.
  - **App State**: `graphql_flutter` for GraphQL data handling and caching, and **Riverpod** for global states like authentication.
- **Communication**: GraphQL, with `graphql_codegen` for generating client files.
- **UI Catalog**: Widgetbook for maintaining a catalog of reusable UI components.

### Backend (Gin/Go)

- **Framework**: Gin with a **modular monolith** architecture to organize different modules independently.
- **Database**: PostgreSQL, with the **`ent` ORM** for schema management and `atlas` for migrations.
- **Communication**: GraphQL for efficient data querying and mutation.
- **Modularization**: Each module is designed to handle specific domains of functionality, enabling focused and isolated testing.

### Machine Learning (FastAPI/Python)

- **Framework**: FastAPI with an **Onion architecture** to separate core ML logic from external interactions.
- **External Libraries**:
  - **Cloud Natural Language**: For sentiment analysis.
  - **Vertex AI (Gemini-1.5-flash-002)**: To manage generative AI tasks.
  - **Pickle**: For serialized conversation data storage.
- **Standard Libraries**: `datetime` for time-related operations.
- **Communication**: GraphQL endpoints for interaction with backend and frontend.

### Infrastructure (Terraform / DevSecOps)

- **Configuration Management**: **Terraform** to manage cloud resources and infrastructure as code.
- **Cloud Providers**:
  - **Primary**: Google Cloud for most resources.
  - **Secondary**: Sakura Cloud for regional redundancy and data sovereignty.
- **CI/CD**: GitHub Actions to automate building, testing, and deployment for all components, ensuring consistent DevSecOps practices.
- **Shared GraphQL Schema**: Ensures compatibility across frontend and backend.

---

## Data Flow and Communication

1. **Frontend ↔ Backend**: Communicates via GraphQL, with autogenerated client files ensuring compatibility.
2. **Backend ↔ ML Module**: Communication is also facilitated through GraphQL, allowing frontend requests to be routed to ML services as needed.
3. **CI/CD**: Automated pipelines ensure testing, security, and compliance checks across all components before deployment.

---

## Design Patterns

- **MVVM (Frontend)**: This pattern organizes the UI code (View) separately from business logic (ViewModel), promoting testability and separation of concerns.
- **Modular Monolith (Backend)**: Each module is independently testable, and this structure makes it easy to refactor and scale into microservices if necessary.
- **Onion Architecture (Machine Learning)**: Provides a clear separation between the core logic and outer layers, improving maintainability and testability.

---

## Additional Notes

- **Shared GraphQL Schema**: Maintained as a single source of truth for all components.
- **Unified CI/CD Pipelines**: Linting, formatting, and testing are enforced at every stage to ensure code quality and security compliance.

For further details, refer to specific component guides within this documentation directory.
